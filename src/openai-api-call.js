#!/usr/bin/env node
/**
 * Universidad de La Laguna
 * Escuela Superior de Ingeniería y Tecnología
 * Grado en Ingeniería Informática
 * Trabajo de Fin de Grado
 *
 * @author Raimon José Mejías Hernández  <alu0101390161@ull.edu.es>
 * @date 12/02/2024
 * @desc @TODO hacer la descripción
 */
import * as fs from 'fs/promises';
import OpenAI from 'openai';
import z from 'zod';

import { parseInputFile, API, TEMPLATES} from './utils.js';
import { API_RESPONSE_SCHEMA } from './schemas/api-response-schema.js';
import { USER_EXTENSION } from './templates/extension-user-prompts.js';
import { SYSTEM_EXTENSION } from './templates/extension-system-messages.js';
import { README } from './templates/readme-content.js';
'use strict';

/**
 * 
 * @param {*} inputObject 
 * @param {*} options 
 */
function generatePrompt(inputObject, options) {
  let prompts = {};
  let type = options.commandType.toUpperCase();
  prompts.system = TEMPLATES.SYSTEM[type](inputObject);
  let userPrompts = TEMPLATES.USER[type](inputObject);
  prompts.user = [];
  userPrompts.map((prompt) => {
    prompts.user.push({ role: 'user', content: prompt });
  });
  return prompts;
}

/**
 * @description
 * @param {*} apiResponse 
 * @param {*} options 
 */
async function createFiles(prompt, apiResponse, outputDirectory, options) {
  try {
    await fs.mkdir(outputDirectory, { recursive: true });
  } catch(error) {
    console.log('DIRECTIORIO YA EXISTE: ', error.message);
    if (error.code === 'EEXIT') { console.log(`El directorio ya existe`); }
  }
  let readmeContent = TEMPLATES.SYSTEM['README'](prompt, apiResponse, options);
  await fs.writeFile(`${outputDirectory}/README.md`, readmeContent);
  apiResponse.map(async (response, index) => {
    try {
      response = JSON.parse(response);
      API_RESPONSE_SCHEMA.parse(response);
      let file = response.file;
      await fs.writeFile(`${outputDirectory}/${file.name}`, file.content)
      if (apiResponse.errors) { 
        apiResponse.errors.map((error) => {
          console.log(`\x1b[31m${options.llm}>:\x1b[0m ${error}`); 
        });
      }
    } catch (error) {
      if (error instanceof z.ZodError || error instanceof SyntaxError) {
        console.error(`WARNING>: File Nº ${index + 1} generated by the LLM has a bad output format. Skipping that file creation.`);   
      } else {
        throw error;
      }
    }
  });
}

/**
 * 
 * @param {*} prompts 
 * @param {*} options 
 * @returns 
 */
async function call(prompts, options) {
  const openai = new OpenAI({ // Crear un formato de error para que el programa pueda parsear el error sin tener que estar pendiente de los paquetes de las API 
    apiKey: process.env.OPENAI_API_KEY,
    organization: options.org
  });
  const DEFAULT_MODEL = 'gpt-3.5-turbo-0125';
  const assistant = await openai.beta.assistants.create({
    instructions: prompts.system,
    model: DEFAULT_MODEL,
  });
  const thread = await openai.beta.threads.create();
  let apiReponse = [];
  for (let index in prompts.user) {
    await openai.beta.threads.messages.create(thread.id, prompts.user[index]);
    let run = await openai.beta.threads.runs.create(
      thread.id,
      { 
        assistant_id: assistant.id, 
        instructions: prompts.system 
      }
    );
    let attempts = 0;
    const MAX_AMOUNT_OF_ATTEMPTS = 3600;
    while (true) {
      if (attempts > MAX_AMOUNT_OF_ATTEMPTS) {
        await openai.beta.threads.runs.cancel(
          thread.id,
          run.id
        );
        let error = new Error('The run spent all the attempts for completions.');
        error.reason = run.status;
        throw error;
      }
      run = await openai.beta.threads.runs.retrieve(
        thread.id,
        run.id
      );
      let verbose = (attempts % 1000 ===  0);
      if (CheckRunStatus(run, verbose)) { break; };
      attempts++;
    }
    const messages = await openai.beta.threads.messages.list(
      thread.id
    );
    let response = messages.data.filter(message => message.role === 'assistant');
    // console.log(response);
    response = response.map((message) => {
      return message.content.map((content) => {
        return content.text.value;
      }); 
    })
    // console.log(response);
    apiReponse.push(...response.flat());
  }
  await openai.beta.assistants.del(assistant.id);
  return apiReponse;
}

/**
 * 
 * @param {*} run 
 */
function CheckRunStatus(run, verbose) {
  let message = '';
  let error = new Error();
  switch (run.status) {
    case 'failed':
      error.message = 'The run failed while attempting to talk with the AI.';
      error.reason = run.last_error;
      throw error;

    case 'cancelled':
      error.message = 'The run was cancelled by the user or the API.';
      error.reason = run.cancelled_at;
      throw error;

    case 'expired':
      error.message = 'The run expired before the thread ending.';
      error.reason = run.last_error;
      throw error;
    
    case 'queued':
      message = `The run is still in queue. Waiting for the API to received.`;
      break;
    
    case 'in_progress':
      message = `The run is still active. Waiting for the API to response.`;
      break;
  
    case 'completed':
      console.log(`The run has been completed, extracting the AI response.`);
      return true;
    
    default: break;
  }
  if (verbose) {
    console.log(message);
  }
  return false; 
}

/**
 * @description OpenAI specific implementation of the API call @TODO Mejorar esto
 * @param {object} prompts 
 * @param {*} options 
 * @returns 
 */
API['OPENAI'] = async function (inputfile, outputdirectory, options) {
  try {
    console.log(`${options.llm}>: Parsing the user input.`)
    let inputObject = await parseInputFile(inputfile, options);
    console.log(`${options.llm}>: Generating prompts with the user input.`)
    let prompts = generatePrompt(inputObject, options);
    if (options.debug) { console.log(prompts); }
    console.log(`${options.llm}>: Starting API call. This process may take a few seconds.`);
    let response = await call(prompts, options);
    if (options.debug) { console.log(response); }
    console.log(`${options.llm}>: Parsing the response data. Generating the respective files`);
    await createFiles(prompts, response, outputdirectory, options);
  } catch (error) {
    if (error instanceof OpenAI.AuthenticationError) {
      throw new Error('The API key or the organization name is not valid');
    }
    throw error;
  }
}

export { API };